#### 刷题总结

- 单调栈
  - 涉及在一个列表中查找每个元素左边或者右边第一个比它大或者小的元素
- 单调队列
  - 涉及滑动窗口内最大值或者最小值
- 二叉堆
  - 涉及查找最大值、最小值

- 最短路径
  - dijkstra解决，单源最短路径，解决有向无环图无负权边场景，流程是选取离源点最近的点，更新临接点到源点的距离，重复执行节点个数次，最后状态即所有节点到源点距离。
  - 路由器场景也使用dijkstra来计算最短路
    - 路由器获取节点间的耗时（即链路成本，如延迟、带宽或跳数）主要通过动态路由协议来实现，这些协议使路由器能自动交换和更新网络状态信息‌。具体过程涉及以下机制：路由协议的分类与工作原理‌：在链路状态路由协议（如OSPF）中，每个路由器定期创建并广播链路状态包（LSP），该包包含其自身标识、邻居路由器列表及到邻居的链路开销（例如，基于实际测量的延迟或带宽计算）‌。这些LSP通过可靠泛洪（reliable flooding）机制传播到整个网络，确保所有路由器获得一致的全局拓扑视图‌。
路由器收到LSP后，存储并构建链路状态数据库（LSDB），然后独立运行Dijkstra算法，基于链路开销计算最短路径树，并将结果写入路由表‌。
对于直接连接的链路，路由器可直接测量或配置开销（如通过接口带宽或管理员设置），无需协议交换‌。
    - 开销的度量与更新‌：链路开销通常由协议定义的度量值（Metric）表示，如跳数、延迟或带宽，这些值在协议更新时动态调整以反映网络变化‌。例如，OSPF使用带宽作为主要度量，RIP则以跳数为基准‌。当网络拓扑变化（如链路故障），路由器检测并广播新LSP，触发全网的Dijkstra算法重新计算，确保路径实时优化‌。这种机制避免了依赖静态配置的滞后性，提高了路由效率‌。
总之，通过动态广播链路状态和可靠泛洪，路由器能持续获取并更新节点间的耗时数据，支撑Dijkstra算法的高效运行‌。

#### 刷题注意点
- 注意数据类型，使用long long
